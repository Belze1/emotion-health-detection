<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gợi Ý Video Dựa Trên Cảm Xúc</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
        <div class="container">
            <a class="navbar-brand" href="/">Phân Tích Cảm Xúc</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Trang Chủ</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/history">Lịch Sử</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="status-message" id="statusMessage">
            Đang chờ dữ liệu cảm xúc...
        </div>
        
        <div class="emotion-state">
            <h5>Trạng Thái Cảm Xúc Hiện Tại:</h5>
            <div class="emotion-display" id="emotionDisplay"></div>
            <div class="emotion-description mt-2" id="emotionDescription"></div>
            <canvas id="emotionPieChart" width="200" height="200"></canvas>
        </div>
        
        <div class="video-container mt-4" id="videoContainer">
            <div class="loading">Đang chờ dữ liệu...</div>
        </div>
    </div>

    <script>
        let emotionHistory = [];
        let currentEmotions = null;
        let emotionChart = null;
        let currentRecommendations = [];
        let displayedVideoIndexes = new Set();
        let firstEmotionTime = null;

        const socket = io({
            transports: ['websocket'],
            upgrade: false,
            reconnection: true,
            reconnectionAttempts: 5
        });

        const emotions = {
            'happy': 'Vui vẻ',
            'sad': 'Buồn',
            'angry': 'Giận dữ',
            'surprise': 'Ngạc nhiên',
            'neutral': 'Bình thường'
        };

        function calculateAverageEmotions(emotionEntries) {
            if (!emotionEntries || emotionEntries.length === 0) return null;
            
            const avgEmotions = {
                'happy': 0,
                'sad': 0,
                'angry': 0,
                'surprise': 0,
                'neutral': 0
            };
            
            emotionEntries.forEach(entry => {
                Object.keys(avgEmotions).forEach(emotion => {
                    avgEmotions[emotion] += entry.emotions[emotion] || 0;
                });
            });
            
            const count = emotionEntries.length;
            Object.keys(avgEmotions).forEach(emotion => {
                avgEmotions[emotion] /= count;
            });
            
            return avgEmotions;
        }

        function updateEmotionDisplay() {
            const display = document.getElementById('emotionDisplay');
            display.innerHTML = '';
            
            if (!currentEmotions) {
                display.innerHTML = '<div class="emotion-item neutral">Chưa có dữ liệu cảm xúc</div>';
                return;
            }
            
            Object.entries(emotions).forEach(([key, label]) => {
                const value = currentEmotions[key] || 0;
                const item = document.createElement('div');
                item.className = `emotion-item ${key}`;
                item.textContent = `${label}: ${Math.round(value * 100)}%`;
                display.appendChild(item);
            });

            updateEmotionChart();
        }

        function updateEmotionChart() {
            const ctx = document.getElementById('emotionPieChart').getContext('2d');
            
            if (emotionChart) {
                emotionChart.destroy();
            }

            const colors = {
                'happy': 'rgba(75, 192, 192, 0.8)',
                'sad': 'rgba(54, 162, 235, 0.8)',
                'angry': 'rgba(255, 99, 132, 0.8)',
                'surprise': 'rgba(255, 206, 86, 0.8)',
                'neutral': 'rgba(153, 102, 255, 0.8)'
            };

            const data = Object.entries(emotions).map(([key]) => ({
                key: key,
                value: (currentEmotions && currentEmotions[key]) || 0
            }));

            emotionChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: data.map(d => emotions[d.key]),
                    datasets: [{
                        data: data.map(d => d.value * 100),
                        backgroundColor: data.map(d => colors[d.key])
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right'
                        }
                    }
                }
            });
        }

        function fetchRecommendations() {
            if (emotionHistory.length === 0 || !firstEmotionTime) {
                document.getElementById('statusMessage').textContent = 'Đang chờ dữ liệu cảm xúc...';
                return;
            }

            document.getElementById('statusMessage').textContent = 'Đang tính toán cảm xúc trung bình...';
            
            const currentTime = new Date();
            const usageDuration = (currentTime - firstEmotionTime) / (1000 * 60); // Thời gian sử dụng tính bằng phút
            
            let relevantEmotions;
            if (usageDuration < 5) {
                relevantEmotions = calculateAverageEmotions(emotionHistory);
                console.log(`Sử dụng trung bình cảm xúc từ tất cả ${emotionHistory.length} mẫu (${usageDuration.toFixed(2)} phút)`);
            } else {
                const fiveMinutesAgo = new Date(currentTime - 5 * 60 * 1000);
                const recentEmotions = emotionHistory.filter(item => item.timestamp >= fiveMinutesAgo);
                relevantEmotions = calculateAverageEmotions(recentEmotions);
                console.log(`Sử dụng trung bình cảm xúc từ ${recentEmotions.length} mẫu trong 5 phút gần nhất`);
            }
            
            currentEmotions = relevantEmotions;
            updateEmotionDisplay();
            
            document.getElementById('statusMessage').textContent = 'Đang tìm kiếm video phù hợp...';
            
            fetch('/api/recommendations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ 
                    emotion_data: currentEmotions,
                    exclude_videos: Array.from(displayedVideoIndexes)
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                if (!data.recommendations || data.recommendations.length === 0) {
                    throw new Error('Không tìm thấy video phù hợp');
                }
                currentRecommendations = data.recommendations;
                displayVideos();
                document.getElementById('statusMessage').textContent = 
                    `Video được gợi ý dựa trên cảm xúc trung bình ${usageDuration.toFixed(1)} phút`;
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('statusMessage').textContent = 
                    `Lỗi: ${error.message}`;
                document.getElementById('videoContainer').innerHTML = 
                    '<div class="loading">Không thể tải video. Vui lòng thử lại.</div>';
            });
        }

        function displayVideos() {
            const container = document.getElementById('videoContainer');
            container.innerHTML = '';
            
            if (!currentRecommendations || currentRecommendations.length === 0) {
                container.innerHTML = '<div class="loading">Không tìm thấy video phù hợp</div>';
                return;
            }
            
            currentRecommendations.slice(0, 4).forEach((video, index) => {
                displayedVideoIndexes.add(video.video_id);
                const card = createVideoCard(video, index);
                container.appendChild(card);
            });
        }

        function createVideoCard(video, index) {
            const card = document.createElement('div');
            card.className = 'video-card';
            card.id = `video-${index}`;
            
            const similarity = Math.round(video.similarity * 100);
            
            card.innerHTML = `
                <iframe 
                    class="video-frame"
                    src="https://www.youtube.com/embed/${video.video_id}"
                    frameborder="0"
                    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen>
                </iframe>
                <div class="video-info">
                    <div class="video-title">${video.title}</div>
                    <div class="similarity-score">Độ phù hợp: ${similarity}%</div>
                    <div class="feedback-buttons">
                        <button class="feedback-button like-button" onclick="sendFeedback('${video.video_id}', 'like', ${index})">
                            👍 Thích
                        </button>
                        <button class="feedback-button dislike-button" onclick="sendFeedback('${video.video_id}', 'dislike', ${index})">
                            👎 Không thích
                        </button>
                    </div>
                </div>
            `;
            
            return card;
        }

        function sendFeedback(videoId, feedbackType, index) {
            document.getElementById('statusMessage').textContent = 'Đang cập nhật phản hồi...';
            
            fetch('/api/feedback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    video_id: videoId,
                    feedback_type: feedbackType,
                    emotion_data: currentEmotions
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }

                if (feedbackType === 'dislike') {
                    replaceVideo(index, videoId);
                } else {
                    document.getElementById('statusMessage').textContent = 'Cảm ơn phản hồi của bạn!';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('statusMessage').textContent = 
                    'Không thể cập nhật phản hồi. Vui lòng thử lại.';
            });
        }

        function replaceVideo(index, oldVideoId) {
            fetch('/api/recommendations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ 
                    emotion_data: currentEmotions,
                    exclude_videos: [...displayedVideoIndexes, oldVideoId]
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error || !data.recommendations || data.recommendations.length === 0) {
                    throw new Error('Không tìm thấy video thay thế phù hợp');
                }

                const newVideo = data.recommendations[0];
                displayedVideoIndexes.delete(oldVideoId);
                displayedVideoIndexes.add(newVideo.video_id);
                
                const videoCard = document.getElementById(`video-${index}`);
                if (videoCard) {
                    const newCard = createVideoCard(newVideo, index);
                    videoCard.replaceWith(newCard);
                }
                document.getElementById('statusMessage').textContent = 'Đã cập nhật video gợi ý';
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('statusMessage').textContent = 
                    'Không thể tải video thay thế. Vui lòng thử lại.';
            });
        }

        // Socket events
        socket.on('connect', function() {
            console.log('Socket connected');
        });

        socket.on('emotion_update', function(data) {
            console.log('Received emotion update:', data);
            
            if (!firstEmotionTime) {
                firstEmotionTime = new Date();
                console.log('First emotion received at:', firstEmotionTime);
            }
            
            emotionHistory.push({
                timestamp: new Date(),
                emotions: data.emotions
            });
            
            if (emotionHistory.length > 180) { // Giữ 30 phút dữ liệu
                emotionHistory.shift();
            }
            
            fetchRecommendations();
        });

        // Khôi phục trạng thái khi tải trang
        document.addEventListener('DOMContentLoaded', function() {
            const savedFirstTime = localStorage.getItem('firstEmotionTime');
            const savedHistory = localStorage.getItem('emotionHistory');

            if (savedFirstTime && savedHistory) {
                try {
                    firstEmotionTime = new Date(savedFirstTime);
                    const parsedHistory = JSON.parse(savedHistory);
                    emotionHistory = parsedHistory.map(item => ({
                        timestamp: new Date(item.timestamp),
                        emotions: item.emotions
                    }));
                    
                    // Chỉ giữ lại dữ liệu trong vòng 30 phút
                    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
                    emotionHistory = emotionHistory.filter(item => item.timestamp >= thirtyMinutesAgo);
                    
                    console.log(`Khôi phục ${emotionHistory.length} mẫu cảm xúc từ phiên trước`);
                    
                    if (emotionHistory.length > 0) {
                        fetchRecommendations();
                    }
                } catch (e) {
                    console.error('Error restoring saved state:', e);
                    emotionHistory = [];
                    firstEmotionTime = null;
                }
            }
        });

        // Lưu trạng thái trước khi rời trang
        window.addEventListener('beforeunload', function() {
            if (firstEmotionTime && emotionHistory.length > 0) {
                localStorage.setItem('firstEmotionTime', firstEmotionTime.toISOString());
                localStorage.setItem('emotionHistory', JSON.stringify(
                    emotionHistory.map(item => ({
                        timestamp: item.timestamp.toISOString(),
                        emotions: item.emotions
                    }))
                ));
            }
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>